package algorithm.动态规划;

/**
 * 带约束爬楼梯
 *
 * 给定一个共有n阶的楼梯，你每步可以上1阶或者2阶，但不能连续两轮跳1阶，请问有多少种方案可以爬到楼顶？
 *
 *  此时这个问题就不满足单纯的【无后效性】了
 *  因为：下一步的选择不能由当前状态(当前所在楼梯阶数)独立决定，还和上一个状态(上一轮所在楼梯阶数)有关
 *
 *  此时需要扩展状态定义：
 *
 *  状态[i,j]表示处在第i阶并且上一轮跳了j阶，其中j取值是1或者2
 *
 *  此时有以下2个定论：
 *
 *      1. 当上一轮跳了1阶时，上上轮只能选择跳2阶，即dp[i, 1]只能是从dp[i-1, 2]转移过来的
 *      2. 当上一轮跳了2阶时，上上轮可以选择跳1阶或跳2阶，即dp[i, 2]可以从dp[i-2, 1]或dp[i-2, 2]转移过来
 *
 *      转移方程就是：
 *
 *      dp[i, 1] = dp[i-1, 2]
 *      dp[i, 2] = dp[i-2, 1] + dp[i-2, 2]
 *
 *
 */
public class climbing_stairs_constraint_dp {

    // 带约束爬楼梯：动态规划
    public int climbingStairsConstrantDP (int n) {
        if (n == 1 || n == 2) return 1;
        // 初始化dp表，用于存储子问题的解
        int[][] dp = new int[n+1][3];
        // 初始状态：预设最小子问题的解
        dp[1][1] = 1;
        dp[1][2] = 0;
        dp[2][1] = 0;
        dp[2][2] = 1;
        // 状态转移：从较小子逐步求解较大子问题
        for (int i=3;i<=n;i++) {
            dp[i][1] = dp[i-1][2];
            dp[i][2] = dp[i-2][1] + dp[i-2][2];
        }
        return dp[n][1] + dp[n][2];
    }
}
